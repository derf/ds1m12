#!/usr/bin/env perl

use strict;
use warnings;
use 5.014;
use Net::Pcap qw(:functions);

our $VERSION = '0.00';

my $URB_INTERRUPT = 1;
my $URB_CONTROL = 2;
my $URB_BULK = 3;

my $URB_SUBMIT = ord('S');
my $URB_COMPLETE = ord('C');

my @sequences;
my $outbuf;

my $cnt    = 0;
my $format = <<'EOF';
	H16 # ID
	C   # type
	C   # transtype
	C   # endpoint
	C   # device
	S   # bus ID
	C   # request
	C   # data?
	H16 # seconds
	L   # usecs
	L   # status
	L   # length
	L   # data length
	C   # bmReqType
	C   # bRequest
	S   # wValue
	S   # wIndex
	S   # wLength
	H*  # data
EOF

sub dump_sequences {

	for my $id (0 .. $#sequences ) {
		my $buf = q{};
		for my $offset (0 .. ((length($sequences[$id]) / 2) - 1)) {
			$buf .= sprintf('0x%s, ',
				substr($sequences[$id], $offset * 2, 2));
		}
		substr($buf, -2, 2, q{});
		printf("unsigned char seq_%d[] = {%s};\n",
			$id, $buf);
	}
}

sub get_sequence_no {
	my ($data) = @_;

	for my $id ( 0 .. $#sequences ) {
		if ($sequences[$id] eq $data) {
			return "seq_${id}";
		}
	}
	push(@sequences, $data);
	return "seq_$#sequences";
}

sub process_packet {
	my ( $user_data, $header, $packet ) = @_;

	my (
		$id,     $type,   $transtype,   $endpoint, $device,
		$busid,  $req,    $dataflag,    $sec,      $usec,
		$status, $length, $datalength,, $bmreqtype,
		$breq,   $wvalue, $windex,      $wlen,     $data
	) = unpack( $format, $packet );

	$cnt++;

	if ( $device != 14 ) {
		return;
	}

	if ($breq ~~ [6, 9]) {
		return;
	}

	if ($bmreqtype >= 0x80) {
		return;
	}

#	printf( "    ID %s (%d)\n  type %c\n ttype %d\n",
#		$id, $cnt, $type, $transtype );
#	printf( "    ep %02x\n   dev %3d\n busid %02x\n",
#		$endpoint, $device, $busid );
#	printf( "  sreq %s\n data? %02x\nstatus %s\n", $req, $dataflag, $status );
#	printf( "   len %s\n  dlen %s\n", $length, $datalength );
#	printf( "brtype %02x\n", $bmreqtype );
#	printf( "  breq %d\nwvalue %d\nwindex %d\n", $breq, $wvalue, $windex );
#	printf( "  wlen %s\n  data %s\n\n", $wlen || 0, $data // q{} );

	if ($type == $URB_SUBMIT) {
		if ($transtype == $URB_CONTROL) {
			$outbuf .= sprintf("ds1m12_control_out(handle, %d, %d, %d);",
				$breq, $windex, $wvalue);
		}
		elsif ($transtype == $URB_BULK and $endpoint < 0x80) {
			$outbuf .= sprintf("ds1m12_bulk_out(handle, %d, %s, %d);",
				$endpoint & 0x7f,
				get_sequence_no($data), length($data) / 2);
		}
	}
	elsif ($type == $URB_COMPLETE) {
		if ($transtype == $URB_BULK and $endpoint >= 0x80) {
			$outbuf .= sprintf("ds1m12_bulk_in(handle, %d, 0, NULL);",
				$endpoint & 0x7f);
		}
	}

	$outbuf .= sprintf("   // %05d\n", $cnt);
}

my $err;
my $pcap = pcap_open_offline( 'ds1m12', \$err );

pcap_loop( $pcap, -1, \&process_packet, undef );

pcap_close($pcap);

dump_sequences();
say $outbuf;

__END__

=head1 NAME

=head1 SYNOPSIS

=head1 VERSION

=head1 DESCRIPTION

=head1 OPTIONS

=over

=back

=head1 EXIT STATUS

=head1 CONFIGURATION

None.

=head1 DEPENDENCIES

=over

=back

=head1 BUGS AND LIMITATIONS

=head1 AUTHOR

Copyright (C) 2013 by Daniel Friesel E<lt>derf@finalrewind.orgE<gt>

=head1 LICENSE

  0. You just DO WHAT THE FUCK YOU WANT TO.
